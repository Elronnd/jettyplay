/*
 * MainFrame.java
 */

package jettyplay;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Font;
import java.awt.RenderingHints;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.net.URISyntaxException;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.HierarchyEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.text.AttributedString;
import java.util.Arrays;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.stream.MemoryCacheImageOutputStream;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.Timer;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileFilter;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSlider;
import javax.swing.JSpinner;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/**
 * The application's main frame.
 */
@SuppressWarnings("serial")
public class MainFrame extends JFrame
implements ClipboardOwner, TemporalProgress {

	/**
	 * Creates a new main window for the Jettyplay application.
	 */
	public MainFrame() {
		initComponents();
		// some components the autogenerated code doesn't know about
		sidebarPane = new SidebarPanel(new AttributedString[] {
				new AttributedString("This is a free GPL program, but comes with "+
						"no warranty. See Help | Licence Information for details.")
				});
		sidebarToolbar.add(sidebarPane);

		SwingUtilities.invokeLater(new Runnable() {
				public void run() {
				setIconImage(new ImageIcon(MainFrame.class.getClassLoader().
							getResource("jettyplay/resources/icon.png")).getImage());
				}
				});
		// set no file to be open
		currentSource = null;

		// initialize the streaming timer
		// all this one does is change the max time on a streaming recording
		// whose length is not known (i.e. still streaming)
		streamingTimer = new Timer(500, new ActionListener() {
				public void actionPerformed(ActionEvent e) {
				Ttyrec r = getCurrentTtyrec();
				try {
				if (r != null && r.isStreaming()
						&& !currentSource.knownLength()) {
				r.setLengthOffset((double) (new Date().getTime()
							- r.getLastActivity().getTime()) / 1000.0);
				synchSliderMaximum();
				updateSidebar();
				}
				} catch (NullPointerException ex) {
				// do nothing; source must have vanished asynchronously
				// while trying to run the command
				}
				}
				});
		streamingTimer.start();

		// initialize the playing timer
		// default play rate is 50fps; most of the time it's very quick to
		// update (nothing moves but the slider), so a high rate is fine
		playTimer = new Timer(50, new ActionListener() {

				public void actionPerformed(ActionEvent e) {
				if (autoskipButton.isSelected() &&
						previousFrameIndex != getCurrentTtyrec().getFrameCount() - 1 &&
						(double)speedSpinner.getValue() > 0) {
				double curTime = timeSlider.getValue() / timeScaling;
				double nextFrameTime =
				getCurrentTtyrec().getFrameAtIndex(previousFrameIndex + 1).
				getRelativeTimestamp();
				double thisFrameTime =
				getCurrentFrame().
				getRelativeTimestamp();
				// We want to scale logarithmically; we reduce the length
				// of the frame to its natural logarithm plus one, unless
				// it's already at 1 or below.
				if (nextFrameTime - thisFrameTime > 1 &&
						(curTime - thisFrameTime) >
						Math.log(nextFrameTime - thisFrameTime) + 1) {
				// Skip to the next frame.
				goForwardOneFrame(null);
				return;
				}
				}
				canUpdateTimeStartedAt = false; // prevent rounding error accumulation
				if (timeSlider.getValue() != timeSlider.getMaximum() ||
						(double)speedSpinner.getValue() < 0) {
					// Don't update the value if already at the end and going
					// forwards; that can cause the frame to glitch back to a previous
					// one if there's two frames at almost the same time at the end
					// of the recording.
					timeSlider.setValue((int)(sliderValueStartedAt +
								(double) (new Date().getTime() - timeStartedAt) *
								(double)speedSpinner.getValue() * timeScaling / 1000));
				}
				if ((double)speedSpinner.getValue() > 0) {
					if (previousFrameIndex == getCurrentTtyrec().getFrameCount() - 1 &&
							(!getCurrentTtyrec().isStreaming() ||
							 getCurrentSource().knownLength())) {
						playing = false;
						playButton.setSelected(false);
						playPauseMenuItem.setSelected(false);
						playTimer.stop();
						updateSidebar();
					} else if (timeSlider.getValue() == timeSlider.getMaximum())
						goForwardOneFrame(null);
				} else {
					// Not quite symmetrical with the case of going forwards;
					// the last frame can be selected only at the very end of
					// the recording, whereas the first frame lasts for positive
					// rather than zero time. Also, we can stop playing after
					// rewinding to the start even if streaming, because the
					// start of the stream doesn't move further back in time.
					if (previousFrameIndex == 0) {
						if (timeSlider.getValue() == timeSlider.getMinimum()) {
							playing = false;
							playButton.setSelected(false);
							playPauseMenuItem.setSelected(false);
							playTimer.stop();
							updateSidebar();
						}
					} else if (timeSlider.getValue() == timeSlider.getMinimum())
						goBackOneFrame(null);
				}
				}
		});
	}

	/**
	 * Shows the About... dialog box.
	 */
	public void showAboutBox() {
		if (aboutBox == null) {
			JFrame mainFrame = this;
			aboutBox = new AboutDialog(mainFrame);
			aboutBox.setLocationRelativeTo(mainFrame);
		}
		aboutBox.setVisible(true);
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 */
	@SuppressWarnings("unchecked")
		private void initComponents() {
			/* This was originally generated by NetBean's Form Editor, but it
			 * lost track of the form upon an upgrade to a new version. So now
			 * it's being edited by hand.
			 */
			uiBuilder = new UIBuilder(false);

			mainPanel = uiBuilder.addJPanel(getContentPane(), null);
			timePanel = uiBuilder.addJPanel(mainPanel, BorderLayout.SOUTH);
			JPanel mainToolbarPanel = uiBuilder.addJPanel(mainPanel, BorderLayout.CENTER);

			timeSlider = uiBuilder.addJSlider(timePanel, BorderLayout.CENTER,
					"Seek to time", new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					timeSliderStateChanged(evt);
					}
					});
			timeSlider.setUI(new LoadingProgressSliderUI(timeSlider,this));
			timeSlider.setValue(0);
			timeSlider.setMaximum(1);

			curTime = uiBuilder.addJLabel(timePanel, BorderLayout.LINE_START,
					"0:00",SwingConstants.RIGHT);
			maxTime = uiBuilder.addJLabel(timePanel, BorderLayout.LINE_END,
					"0:00",SwingConstants.LEFT);

			mainToolbar = uiBuilder.addJToolBar(mainToolbarPanel, BorderLayout.NORTH);

			uiBuilder.addJButton(mainToolbar,"Go to the start of the recording",
					"first.png", new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goToStart(evt);
					}
					});
			uiBuilder.addJButton(mainToolbar,"Go backward one frame",
					"backframe.png",new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goBackOneFrame(evt);
					}
					});
			playButton = uiBuilder.addJToggleButton(mainToolbar,"Start or pause playback",
					"play.png", true,new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					playButtonChanged(evt);
					}
					});
			uiBuilder.addJButton(mainToolbar,"Go forward one frame",
					"forwardframe.png",new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goForwardOneFrame(evt);
					}
					});
			uiBuilder.addJButton(mainToolbar,"Go to the end of the recording",
					"last.png",new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goToEnd(evt);
					}
					});
			uiBuilder.addJSeparator(mainToolbar);

			/* We do this one by hand, because it's a little complex and because
			   there's no code reuse benefit from uiBuilder. */
			speedSpinner = new JSpinner(new SpinnerNumberModel(Double.valueOf(1.0d),
						null, null, Double.valueOf(1.0d)));
			speedSpinner.setToolTipText("Speed at which to replay the ttyrec");
			speedSpinner.setEditor(new JSpinner.DefaultEditor(speedSpinner));
			speedSpinner.setFocusable(false);
			((JSpinner.DefaultEditor)speedSpinner.getEditor())
				.getTextField().setFocusable(false);
			speedSpinner.setPreferredSize(
					new Dimension((int)(mainToolbar.getPreferredSize().getHeight()-4),
						(int)speedSpinner.getMinimumSize().getHeight()));
			speedSpinner.setMaximumSize(speedSpinner.getPreferredSize());
			((JSpinner.DefaultEditor)speedSpinner.getEditor()).getTextField()
				.addMouseListener(new MouseAdapter() {
						public void mouseClicked(MouseEvent evt) {
						speedSpinnerMouseClicked(evt);
						}
						});
			speedSpinner.addMouseListener(new MouseAdapter() {
					public void mouseClicked(MouseEvent evt) {
					speedSpinnerMouseClicked(evt);
					}
					});
			speedSpinner.addChangeListener(new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					speedSpinnerStateChanged(evt);
					}
					});
			mainToolbar.add(speedSpinner);

			autoskipButton = uiBuilder.addJToggleButton(mainToolbar,
					"Automatically skip past long periods of inactivity",
					"autoskip.png", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autoskipButtonStateChanged(evt);
					}
					});

			sidebarToolbarPanel = uiBuilder.addJPanel(mainToolbarPanel,
					BorderLayout.CENTER);

			sidebarToolbar = uiBuilder.addJToolBar(sidebarToolbarPanel,
					BorderLayout.SOUTH);
			sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar, BoxLayout.X_AXIS));

			/* Another by-hand addition. */
			sidebarTypeComboBox = new JComboBox<>();
			sidebarTypeComboBox.setModel(new DefaultComboBoxModel<>(
						new String[] { "Properties", "Annotations", "Playlist", "Raw Data" }));
			sidebarTypeComboBox.setFocusable(false);
			sidebarTypeComboBox.setMaximumSize(sidebarTypeComboBox.getPreferredSize());
			sidebarTypeComboBox.setName("sidebarTypeComboBox"); // NOI18N
			sidebarTypeComboBox.addItemListener(new ItemListener() {
					public void itemStateChanged(ItemEvent evt) {
					sidebarTypeComboBoxItemStateChanged(evt);
					}
					});
			sidebarTypeComboBox.addHierarchyBoundsListener(new HierarchyBoundsListener() {
					public void ancestorMoved(HierarchyEvent evt) {
					}
					public void ancestorResized(HierarchyEvent evt) {
					sidebarTypeComboBoxAncestorResized(evt);
					}
					});
			sidebarToolbar.add(sidebarTypeComboBox);

			menuBar = new JMenuBar();

			fileMenu = uiBuilder.addJMenu(menuBar, 'f', "File");
			uiBuilder.addJMenuItem(fileMenu, 'o', "Open...", "control O", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					openMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(fileMenu);
			uiBuilder.addJMenuItem(fileMenu, 'v', "Save as Video...", null,
					true, new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					saveAsVideoMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(fileMenu);
			uiBuilder.addJMenuItem(fileMenu, 'x', "Exit", "control X", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					exitMenuItemActionPerformed(evt);
					}
					});

			JMenu editMenu = uiBuilder.addJMenu(menuBar, 'e', "Edit");
			uiBuilder.addJMenuItem(editMenu, 'f', "Find...", "control F", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					findMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(editMenu);
			screenshotMenu = uiBuilder.addJMenu(editMenu, 'c',
					"Copy Screenshot");
			uiBuilder.addJMenuItem(screenshotMenu, 'p', "As Plain Text",
					null, true, new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					plainTextScreenshotMenuItemActionPerformed(evt);
					}
					});
			viewMenu = uiBuilder.addJMenu(menuBar, 'v', "View");
			fullScreenMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'f',
					"Full Screen", "F11", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					fullScreenMenuItemStateChanged(evt);
					}
					});
			fullScreenMenuItem.setEnabled(
					GraphicsEnvironment.getLocalGraphicsEnvironment()
					.getDefaultScreenDevice().isFullScreenSupported());
			sidebarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'i',
					"Information Bar", null, false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					sidebarMenuItemStateChanged(evt);
					}
					});
			sidebarMenuItem.setSelected(true);
			toolBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 't',
					"Toolbar", null, false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					toolBarMenuItemStateChanged(evt);
					}
					});
			toolBarMenuItem.setSelected(true);
			menuBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'm',
					"Menu Bar", "control M", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					menuBarMenuItemStateChanged(evt);
					}
					});
			menuBarMenuItem.setSelected(true);
			controlBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'c',
					"Control Bar", null, false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					controlBarMenuItemStateChanged(evt);
					}
					});
			controlBarMenuItem.setSelected(true);
			uiBuilder.addJSeparator(viewMenu);
			ButtonGroup terminalSizeGroup = new ButtonGroup();
			JMenu terminalSizeMenu = uiBuilder.addJMenu(viewMenu, 'z', "Terminal Size");
			autodetectTerminalSizeMenuItem = uiBuilder.addJRadioButtonMenuItem(
					terminalSizeMenu, 'a', "Autodetect", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autodetectTerminalSizeMenuItemActionPerformed(evt);
					}
					});
			terminalSizeGroup.add(autodetectTerminalSizeMenuItem);
			autodetectTerminalSizeMenuItem.setSelected(true);
			fixedTerminalSizeMenuItem = uiBuilder.addJRadioButtonMenuItem(
					terminalSizeMenu, 'f', "Fixed Size...", null, true,
					new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {}
					});
			fixedTerminalSizeMenuItem.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					fixedTerminalSizeMenuItemActionPerformed(evt);
					}
					});
			encodingMenu = uiBuilder.addJMenu(viewMenu, 'e', "Encoding");
			ButtonGroup encodingButtonGroup = new ButtonGroup();
			autodetectEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'a', "Autodetect", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autodetectEncodingMenuItemStateChanged(evt);
					}
					});
			encodingButtonGroup.add(autodetectEncodingMenuItem);
			autodetectEncodingMenuItem.setSelected(true);
			unicodeEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'u', "Unicode (UTF-8)", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					unicodeEncodingMenuItemStateChanged(evt);
					}
					});
			encodingButtonGroup.add(unicodeEncodingMenuItem);
			ibmEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'i', "IBM (IBM850)", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					ibmEncodingMenuItemStateChanged(evt);
					}
					});
			encodingButtonGroup.add(autodetectEncodingMenuItem);
			latin1EncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'l', "Latin-1 (ISO-8859-1)", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					latin1EncodingMenuItemStateChanged(evt);
					}
					});
			JMenu goMenu = uiBuilder.addJMenu(menuBar, 'g', "Go");
			playPauseMenuItem = uiBuilder.addJCheckBoxMenuItem(goMenu, 'p',
					"Play", "SPACE", true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					updatePlayPaused(evt);
					}
					});
			uiBuilder.addJSeparator(goMenu);
			uiBuilder.addJMenuItem(goMenu, 't', "To Start", "HOME", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goToStart(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 'e', "To End", "END", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goToEnd(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 'n', "Back One Frame", "LEFT", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goBackOneFrame(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 'f', "Forward One Frame", "RIGHT", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goForwardOneFrame(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 'a', "To Frame...", "G", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goToSpecificFrameMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(goMenu);
			uiBuilder.addJMenuItem(goMenu, 'q', "Quicker", "UP", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goQuickerMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 's', "Slower", "DOWN", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goSlowerMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 'n', "Normal Speed", "1", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goTimesOneMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJMenuItem(goMenu, 'i', "Specific Speed", "X", false,
					new ActionListener () {
					public void actionPerformed(ActionEvent evt) {
					speedSpinnerMouseClicked(null);
					}
					});

			uiBuilder.addJMenuItem(goMenu, 'r', "Reverse Direction", "R", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					goRewindMenuItemActionPerformed(evt);
					}
					});
			autoskipMenuItem =uiBuilder.addJCheckBoxMenuItem(goMenu,
					'k', "Skip Inactivity", "L", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autoskipMenuItemStateChanged(evt);
					}
					});
			JMenu helpMenu = uiBuilder.addJMenu(menuBar, 'h', "Help");
			uiBuilder.addJMenuItem(helpMenu, 'a', "About...", null, false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					aboutMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJMenuItem(helpMenu, 'l', "License information...", null,
					false, new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					licenceMenuItemActionPerformed(evt);
					}
					});

			setJMenuBar(menuBar);
			uiBuilder.massSetEnabled(false);
		}

	/**
	 * A function that runs when the Open menu item is selected, that opens
	 * a ttyrec file.
	 * @param evt Information on which event was performed
	 */
	private void openMenuItemActionPerformed(ActionEvent evt) {
		InputStreamable iStream = null;

		BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));

		boolean gotstring = false;
		String s = "";
		while (!gotstring) {
			try {
				s = stdin.readLine();
				gotstring = true;
			} catch (IOException e) {
			}
		}


		File f = new File(s);
		iStream = new InputStreamableFileWrapper(f);

		if (iStream == null) return;

		openSourceFromInputStreamable(iStream);
	}

	private void timeSliderStateChanged(ChangeEvent evt) {
		if (getCurrentTtyrec() == null) return;
		setTimeLabels();
		int i = getCurrentTtyrec().getFrameIndexAtRelativeTime(
				(double) timeSlider.getValue() / timeScaling);
		if (canUpdateSelectedFrame)
			goToSpecificFrame(i, false);
		else
			canUpdateSelectedFrame = true;
		if (!canUpdateTimeStartedAt) {
			canUpdateTimeStartedAt = true;
			return;
		}
		timeStartedAt = new Date().getTime();
		sliderValueStartedAt = timeSlider.getValue();
	}

	private void updatePlayPaused(ChangeEvent evt) {
		if (getCurrentTtyrec() == null) return;
		playing = playPauseMenuItem.isSelected();
		if (playing) {
			timeStartedAt = new Date().getTime();
			sliderValueStartedAt = timeSlider.getValue();
			if ((Double)speedSpinner.getValue() == 0)
				speedSpinner.setValue(1.0);
			playTimer.restart();
		} else
			playTimer.stop();
		if (playPauseMenuItem.isSelected() != playButton.isSelected())
			playButton.setSelected(playPauseMenuItem.isSelected());
		updateSidebar();
	}

	private void playButtonChanged(ChangeEvent evt) {
		if (playPauseMenuItem.isSelected() != playButton.isSelected())
			playPauseMenuItem.setSelected(playButton.isSelected());
	}

	private void goToStart(ActionEvent evt) {
		goToSpecificFrame(0, true);
	}

	private void goToEnd(ActionEvent evt) {
		// The time of the last frame might not equal the end of the recording
		// if we're streaming. And the end of the recording might not equal the
		// time of the last frame if the recording ends with two frames less
		// than a millisecond apart. So the solution is to set both separately.
		timeSlider.setValue(timeSlider.getMaximum());
		goToSpecificFrame(getCurrentTtyrec().getFrameCount()-1, false);
	}

	private void goBackOneFrame(ActionEvent evt) {
		goToSpecificFrame(previousFrameIndex-1, true);
	}

	private void goForwardOneFrame(ActionEvent evt) {
		goToSpecificFrame(previousFrameIndex+1, true);
	}

	private void licenceMenuItemActionPerformed(ActionEvent evt) {
		new LicenceDialog(this).setVisible(true);
	}

	private void autoskipButtonStateChanged(ChangeEvent evt) {
		autoskipMenuItem.setSelected(autoskipButton.isSelected());
		updateSidebar();
	}

	private void autoskipMenuItemStateChanged(ChangeEvent evt) {
		autoskipButton.setSelected(autoskipMenuItem.isSelected());
		updateSidebar();
	}

	private void unicodeEncodingMenuItemStateChanged(ChangeEvent evt) {
		if (unicodeEncodingMenuItem.isSelected())
			setTtyrecFormat(Ttyrec.Encoding.UTF8);
	}

	private void ibmEncodingMenuItemStateChanged(ChangeEvent evt) {
		if (ibmEncodingMenuItem.isSelected())
			setTtyrecFormat(Ttyrec.Encoding.IBM);
	}

	private void latin1EncodingMenuItemStateChanged(ChangeEvent evt) {
		if (latin1EncodingMenuItem.isSelected())
			setTtyrecFormat(Ttyrec.Encoding.Latin1);
	}

	private void fullScreenMenuItemStateChanged(ChangeEvent evt) {
		GraphicsEnvironment.getLocalGraphicsEnvironment().
			getDefaultScreenDevice().setFullScreenWindow(
					fullScreenMenuItem.isSelected() ?
					this : null);
	}

	private void sidebarMenuItemStateChanged(ChangeEvent evt) {
		sidebarToolbar.setVisible(sidebarMenuItem.isSelected());
	}

	private void toolBarMenuItemStateChanged(ChangeEvent evt) {
		mainToolbar.setVisible(toolBarMenuItem.isSelected());
	}

	private void menuBarMenuItemStateChanged(ChangeEvent evt) {
		if (menuBarMenuItem.isSelected()) {
			if (!menuBarShowing) {
				//menuBar.setPreferredSize(new Dimension(32767,savedMenuBarHeight));
				menuBar.setPreferredSize(null);
				menuBar.setVisible(false);
				menuBar.setVisible(true);
				menuBarShowing = true;
			}
		} else {
			if (menuBarShowing) {
				menuBar.setPreferredSize(new Dimension(32767,1));
				menuBar.setVisible(false);
				menuBar.setVisible(true);
				menuBarShowing = false;
			}
		}
	}

	private void controlBarMenuItemStateChanged(ChangeEvent evt) {
		timePanel.setVisible(controlBarMenuItem.isSelected());
	}

	private void goRewindMenuItemActionPerformed(ActionEvent evt) {
		speedSpinner.setValue((Double)speedSpinner.getValue() * -1.0);
	}

	private void goTimesOneMenuItemActionPerformed(ActionEvent evt) {
		speedSpinner.setValue(1.0);
	}

	private void goSlowerMenuItemActionPerformed(ActionEvent evt) {
		if (!((Double)speedSpinner.getValue()).equals(1.0))
			speedSpinner.setValue((Double)speedSpinner.getValue() - 1.0);
		else
			speedSpinner.setValue(-1.0);
	}

	private void goQuickerMenuItemActionPerformed(ActionEvent evt) {
		if (!((Double)speedSpinner.getValue()).equals(-1.0))
			speedSpinner.setValue((Double)speedSpinner.getValue() + 1.0);
		else
			speedSpinner.setValue(1.0);
	}

	private void goToSpecificFrameMenuItemActionPerformed(ActionEvent evt) {
		String frameString = JOptionPane.showInputDialog(
				encodingMenu, "Go to which frame?", ""+(previousFrameIndex+1));
		if (frameString == null) return;
		try {
			goToSpecificFrame(Integer.valueOf(frameString) - 1, true);
		} catch (NumberFormatException ex) {
			// ignore invalid input
		}
	}

	private void findMenuItemActionPerformed(ActionEvent evt) {
		if (findBox == null)
			findBox = new FindDialog(this,this);
		findBox.setVisible(true);
		findBox.fixDefaultFocus();
		findBox.requestFocusInWindow();
	}

	private void plainTextScreenshotMenuItemActionPerformed(ActionEvent evt) {
		VDUBuffer vdub = null;
		if (getCurrentTtyrec() != null) vdub = getCurrentFrame().getTerminalState();
		if (vdub == null) vdub = new vt320();
		StringBuilder sb = new StringBuilder();
		for (char[] s: vdub.charArray) {
			sb.append(s);
			sb.append('\n');
		}
		setClipboardContents(new StringSelection(sb.toString()));
	}

	private void speedSpinnerStateChanged(ChangeEvent evt) {
		if ((((Double)speedSpinner.getValue()).equals(0.0)) && playing) {
			playPauseMenuItem.setSelected(false);
			playButton.setSelected(false);
			playing = false;
			playTimer.stop();
		}
		sliderValueStartedAt = timeSlider.getValue();
		timeStartedAt = new Date().getTime();
		updateSidebar();
	}

	private void sidebarTypeComboBoxAncestorResized(HierarchyEvent evt) {
		int oldOrientation = sidebarToolbar.getOrientation();
		sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar,
					oldOrientation == SwingConstants.HORIZONTAL ?
					BoxLayout.X_AXIS : BoxLayout.Y_AXIS));
		// fix layout
		sidebarToolbar.invalidate();
		sidebarToolbar.validate();
		// fix sizing (by forcing a size recalculation)
		sidebarToolbar.setOrientation(SwingConstants.HORIZONTAL);
		sidebarToolbar.setOrientation(SwingConstants.VERTICAL);
		sidebarToolbar.setOrientation(oldOrientation);
		sidebarPane.setVertical(oldOrientation == SwingConstants.VERTICAL);
	}

	private void sidebarTypeComboBoxItemStateChanged(ItemEvent evt) {
		updateSidebar();
	}

	private void speedSpinnerMouseClicked(MouseEvent evt) {
		String frameString = JOptionPane.showInputDialog(
				encodingMenu, "Set speed to what?", ""+(speedSpinner.getValue()));
		if (frameString == null) return;
		try {
			speedSpinner.setValue(Double.valueOf(frameString));
		} catch (NumberFormatException ex) {
			// ignore invalid input
		}
	}

	private void aboutMenuItemActionPerformed(ActionEvent evt) {
		new AboutDialog(this).setVisible(true);
	}

	private void exitMenuItemActionPerformed(ActionEvent evt) {
		System.exit(0);
	}

	private void autodetectEncodingMenuItemStateChanged(ChangeEvent evt) {
		if (autodetectEncodingMenuItem.isSelected() && getCurrentTtyrec() != null)
			getCurrentTtyrec().resetEncoding();
	}

	private void saveAsVideoMenuItemActionPerformed(ActionEvent evt) {
		/* We don't check to see if analyze process is maxed out, because in
		 * the case of streaming ttyrecs, there's no way to tell.
		 */
		if (currentSource.getTtyrec() != null &&
				currentSource.getTtyrec().getFrameCount() > 0 &&
				currentSource.backportDecodeProgress()
				>= currentSource.getTtyrec().getFrameCount())
			new SaveAsVideoDialog(currentSource.getTtyrec(), "/tmp/jettyplay_tmp.avi");
		else
			JOptionPane.showMessageDialog(fileMenu,
					"Please wait for the ttyrec to finish loading first.",
					"Cannot Save as Video", JOptionPane.ERROR_MESSAGE);
	}

	private void autodetectTerminalSizeMenuItemActionPerformed(ChangeEvent evt) {
		if (autodetectTerminalSizeMenuItem.isSelected() && getCurrentTtyrec() != null) {
			getCurrentTtyrec().setForcedSize(-1,-1);
			autodetectTerminalSizeMenuItem.setSelected(true);
			fixedTerminalSizeMenuItem.setSelected(false);
			getCurrentSource().repeatCurrentDecodeWorker();
		}
	}

	private void fixedTerminalSizeMenuItemActionPerformed(ActionEvent evt) {
		if (fixedTerminalSizeMenuItem.isSelected()) {
			String s = JOptionPane.showInputDialog(viewMenu,
					"Fix terminal window at what size (WxH)?", "80x24");
			if (s == null) return;
			setForcedSizeFromString(s);
		}
	}

	private void setForcedSizeFromString(String s) {
		Matcher m = Pattern.compile("\\s*(\\d+)\\s*x\\s*(\\d+)\\s*").
			matcher(s);
		if (!m.matches()) return;
		getCurrentTtyrec().setForcedSize(
				Integer.valueOf(m.group(1)), Integer.valueOf(m.group(2)));
		autodetectTerminalSizeMenuItem.setSelected(false);
		fixedTerminalSizeMenuItem.setSelected(true);
		getCurrentSource().repeatCurrentDecodeWorker();
	}

	private void setClipboardContents(Transferable t) {
		try {
			this.getToolkit().
				getSystemClipboard().setContents(t, this);
		} catch (java.security.AccessControlException ex) {
			try {
				// Try using a JNLP service to access the clipboard.

				// ClipboardService cs = (ClipboardService) ServiceManager.lookup("javax.jnlp.ClipboardService");
				Object cs = getClass().getClassLoader().loadClass("javax.jnlp.ServiceManager").
					getMethod("lookup", String.class).invoke(null, "javax.jnlp.ClipboardService");
				// cs.setContents(t);
				getClass().getClassLoader().loadClass("javax.jnlp.ClipboardService").
					getMethod("setContents", Transferable.class).invoke(cs, t);
			} catch (ClassNotFoundException | NoSuchMethodException |
					SecurityException | IllegalAccessException |
					IllegalArgumentException | InvocationTargetException ex1) {
				return;
			}
		}
	}

	private void setTtyrecFormat(Ttyrec.Encoding format) {
		if (getCurrentTtyrec() == null) return;
		if (getCurrentTtyrec().getEncoding() == format) return;
		getCurrentTtyrec().setEncoding(format);
		getCurrentSource().repeatCurrentDecodeWorker();
	}

	private void goToSpecificFrame(int frame, boolean changeTimeSlider) {
		if (getCurrentTtyrec() == null) return;
		if (frame < 0 || frame >= getCurrentTtyrec().getFrameCount()) return;
		TtyrecFrame f = getCurrentTtyrec().getFrameAtIndex(frame);
		if (changeTimeSlider) {
			timeSlider.setValue((int)Math.ceil(
						f.getRelativeTimestamp() * timeScaling));
			timeSliderStateChanged(null);
		}
		if (frame != previousFrameIndex) {
			f.setDirty(false);
		}
		previousFrameIndex = frame;
		updateSidebar();
	}

	private String timeToString(double time) {
		int t = (int)time;
		if (t<0) t = 0;
		String s = (t/60) + ":";
		if (t > 3600) {
			s = (t/3600) + ":";
			if ((t/60)%60 < 10) s += "0";
			s += (t/60)%60 + ":";
		}
		if (t%60 < 10) s += "0";
		s += t%60;
		return s;
	}

	private void setTimeLabels() {
		if (getCurrentTtyrec() == null) return;
		maxTime.setText(timeToString(getCurrentTtyrec().getLength()));
		curTime.setPreferredSize(maxTime.getPreferredSize());
		curTime.setText(timeToString((double)timeSlider.getValue() / timeScaling));
	}

	private boolean oldEnabled = false;
	private void massSetEnabled(boolean enabled) {
		if (enabled == oldEnabled) return;
		oldEnabled = enabled;
		if (!enabled) {
			unicodeEncodingMenuItem.setEnabled(enabled);
			ibmEncodingMenuItem.setEnabled(enabled);
			latin1EncodingMenuItem.setEnabled(enabled);
		}
		uiBuilder.massSetEnabled(enabled);
	}

	private void unloadFile() {
		playing = false;
		playTimer.stop();
		playPauseMenuItem.setSelected(false);
		playButton.setSelected(false);
		massSetEnabled(false);
		if (getCurrentSource() != null) getCurrentSource().completeCancel();
		currentSource = null;
		maxTime.setText("0:00");
		curTime.setPreferredSize(maxTime.getPreferredSize());
		curTime.setText("0:00");
		timeSlider.setValue(0);
		timeSlider.setMaximum(1);
		timeSlider.repaint();
		VDUBuffer.resetCaches();
		updateSidebar();
	}

	private void openSourceFromInputStreamable(InputStreamable iStream) {
		unloadFile();
		currentSource = new InputStreamTtyrecSource(iStream);
		getCurrentSource().completeUnpause();
		getCurrentSource().addDecodeListener(new ProgressListener() {
				public void progressMade() {
				decodeProgressMade();
				}
				});
		getCurrentSource().addAnalysisListener(new ProgressListener() {
				public void progressMade() {
				analysisProgressMade();
				}
				});
		getCurrentSource().addReadListener(new ProgressListener() {
				public void progressMade() {
				readProgressMade();
				}
				});
		getCurrentSource().start();
		setTimeLabels();
		massSetEnabled(true);
		previousFrameIndex = 0;
		// If viewing an inherently streaming source, set up for streaming;
		// jump to the end and set play mode on.
		if (iStream.mustBeStreamable()) {
			timeSlider.setValue(timeSlider.getMaximum());
			goToSpecificFrame(getCurrentTtyrec().getFrameCount() - 1, false);
			playPauseMenuItem.setSelected(true);
			playButton.setSelected(true);
		}
	}

	// Variable declarations
	private JRadioButtonMenuItem allowBoldMenuItem;
	private JRadioButtonMenuItem autodetectEncodingMenuItem;
	private JRadioButtonMenuItem autodetectTerminalSizeMenuItem;
	private JToggleButton autoskipButton;
	private JCheckBoxMenuItem autoskipMenuItem;
	private JCheckBoxMenuItem controlBarMenuItem;
	private JLabel curTime;
	private JRadioButtonMenuItem disallowBoldMenuItem;
	private JMenu encodingMenu;
	private JMenu fileMenu;
	private JRadioButtonMenuItem fixedTerminalSizeMenuItem;
	private JCheckBoxMenuItem fullScreenMenuItem;
	private JRadioButtonMenuItem ibmEncodingMenuItem;
	private JRadioButtonMenuItem latin1EncodingMenuItem;
	private JPanel mainPanel;
	private JToolBar mainToolbar;
	private JLabel maxTime;
	private JMenuBar menuBar;
	private JCheckBoxMenuItem menuBarMenuItem;
	private JToggleButton playButton;
	private JCheckBoxMenuItem playPauseMenuItem;
	private JMenu screenshotMenu;
	private JCheckBoxMenuItem sidebarMenuItem;
	private JToolBar sidebarToolbar;
	private JPanel sidebarToolbarPanel;
	private JComboBox<String> sidebarTypeComboBox;
	private JSpinner speedSpinner;
	private JPanel timePanel;
	private JSlider timeSlider;
	private JCheckBoxMenuItem toolBarMenuItem;
	private JRadioButtonMenuItem unicodeEncodingMenuItem;
	private JMenu viewMenu;
	private UIBuilder uiBuilder;
	private SidebarPanel sidebarPane;
	private boolean menuBarShowing = true;

	private TtyrecSource currentSource;

	// TODO: Reduce this in the case of excessively time-long ttyrecs,
	// to avoid an integer overflow
	private int timeScaling = 1000;
	private boolean playing = false;
	private final Timer playTimer;
	private final Timer streamingTimer;
	private int previousFrameIndex = -1;
	private long timeStartedAt;
	private int sliderValueStartedAt;
	private boolean canUpdateTimeStartedAt = true;
	private boolean canUpdateSelectedFrame = true;

	private JDialog aboutBox;
	private FindDialog findBox;

	private File lastDirectory = null;

	public double getMaximumTime() {
		if (getCurrentTtyrec() == null) return 0.0;
		return getCurrentTtyrec().getLength();
	}
	public double getCurrentTime() {
		if (getCurrentTtyrec() == null) return 0.0;
		if (getCurrentSource().backportDecodeProgress() ==
				getCurrentTtyrec().getFrameCount())
			return getCurrentTtyrec().getLength();
		if (getCurrentSource().backportDecodeProgress() == 0) return 0.0;
		return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().backportDecodeProgress()-1).getRelativeTimestamp();
	}
	public double getFuzzyTime() {
		if (getCurrentTtyrec() == null) return 0.0;
		if (getCurrentSource().decodeProgress() == getCurrentTtyrec().getFrameCount())
			return getCurrentTtyrec().getLength();
		if (getCurrentSource().decodeProgress() == 0) return 0.0;
		return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().decodeProgress()-1).getRelativeTimestamp();
	}

	private void synchSliderMaximum() {
		if (getCurrentTtyrec() == null) return;
		boolean atmax = timeSlider.getValue() == timeSlider.getMaximum();
		canUpdateTimeStartedAt = false;
		canUpdateSelectedFrame = false;
		timeSlider.setMaximum((int) (getCurrentTtyrec().getLength() * timeScaling));
		if (atmax && playing) {
			canUpdateTimeStartedAt = true;
			// to avoid glitches, let the play loop handle updating the
			// selected frame
			canUpdateSelectedFrame = false;
			timeSlider.setValue(timeSlider.getMaximum());
		}
		timeSlider.repaint();        
		updateSidebar();
		setTimeLabels();
	}

	/**
	 * A listener that should be called whenever progress has been made in
	 * reading an input source for a currently opened ttyrec.
	 */
	public void readProgressMade() {
		synchSliderMaximum();
	}

	/**
	 * A listener that should be called whenever progress has been made in
	 * decoding a currently opened ttyrec.
	 */
	public void decodeProgressMade() {
		timeSlider.repaint();
		updateSidebar();
		if (getCurrentTtyrec() != null &&
				getCurrentTtyrec().getFrameCount() > previousFrameIndex &&
				getCurrentFrame().isDirty()) {
			getCurrentFrame().setDirty(false);
		}
	}

	/**
	 * A listener that should be called whenever progress has been made in
	 * analysing a currently open ttyrec.
	 */
	public void analysisProgressMade() {
		synchSliderMaximum();
		setTimeLabels();
		updateSidebar();
		// Synch the selected encoding from the ttyrec...
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Autodetect)
			autodetectEncodingMenuItem.setSelected(true);
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.IBM)
			ibmEncodingMenuItem.setSelected(true);
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Latin1)
			latin1EncodingMenuItem.setSelected(true);
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.UTF8)
			unicodeEncodingMenuItem.setSelected(true);
		// /before/ setting which item is enabled, or we'll end up copying
		// the old value over the new one rather than vice versa.
		ibmEncodingMenuItem.setEnabled
			(getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.IBM));
		unicodeEncodingMenuItem.setEnabled
			(getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.UTF8));
		latin1EncodingMenuItem.setEnabled
			(getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.Latin1));
		// if we just decoded the wanted frame, jump to it
		if (getCurrentTtyrec().getWantedFrame() > -1 &&
				getCurrentTtyrec().getFrameCount() >
				getCurrentTtyrec().getWantedFrame()) {
			goToSpecificFrame(getCurrentTtyrec().getWantedFrame(), true);
			getCurrentTtyrec().setWantedFrame(-1);
		}
	}

	private TtyrecFrame getCurrentFrame() {
		try {
			return getCurrentTtyrec().getFrameAtIndex(previousFrameIndex);
		} catch(IndexOutOfBoundsException ex) {
			return null;
		}
	}

	private void setSidebarPropertyMessage() {
		if (getCurrentTtyrec() != null) {
			AttributedString[] as = new AttributedString[7];
			as[0] = new AttributedString(playing ? "Playing" : "Paused");
			as[0].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD);
			double time = (double)timeSlider.getValue() / timeScaling;
			as[1] = new AttributedString("Frame: " + (previousFrameIndex+1) +
					" / " + getCurrentTtyrec().getFrameCount());
			as[1].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
			as[2] = new AttributedString("Time: " + timeToString(time) +
					" / " + timeToString(getCurrentTtyrec().getLength()));
			as[2].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,4);
			as[3] = new AttributedString("Speed: x" + speedSpinner.getValue() +
					(autoskipButton.isSelected() ? " log" : ""));
			as[3].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
			try {
				as[4] = new AttributedString("Size: " +
						getCurrentFrame().getTerminalState().getColumns() +
						" x " + getCurrentFrame().getTerminalState().getRows());
			} catch (Exception e) {
				as[4] = new AttributedString("Size: ? x ?");
			}
			as[4].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
			as[5] = new AttributedString("Memory used: " +
					((Runtime.getRuntime().totalMemory()) - Runtime.getRuntime().freeMemory()) +
					" / " + Runtime.getRuntime().maxMemory());
			as[5].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,11);
			try {
				as[6] = new AttributedString("URI: " + getCurrentSource().getURI().toString());
			} catch (URISyntaxException ex) {
				as[6] = new AttributedString("URI: unknown");
			}
			as[6].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,3);
			setSidebarPaneContents(as);
		} else {
			setSidebarPaneContents(new AttributedString[]
					{new AttributedString("No file loaded.")});
		}
	}

	/**
	 * Searches for a given string in the currently open ttyrec; if it's found,
	 * then seeks the current ttyrec to the frame where it was found.
	 * @param searchFor The string to search for.
	 * @param searchForward Whether to search forwards (true) or backwards (false).
	 * @param regex Whether the string to search for is actually a regex.
	 * @param ignoreCase Whether to do a case-insensitive (true) or case-sensitive (false) search.
	 * @param wrapAround Whether to restart the search at one end of the ttyrec if it's finished at the other end.
	 * @return A string that can be displayed to the user, summarising the results of the search.
	 */
	public String searchInTtyrec(String searchFor, boolean searchForward,
			boolean regex, boolean ignoreCase, boolean wrapAround) {
		Pattern p;
		try {
			// Regex.LITERAL would be nice, but it's too new. So we quote the
			// regex by hand, according to Perl 5 quoting rules; all letters
			// and all digits are left as-is, other characters are preceded by
			// a backslash.
			if (!regex) {
				StringBuilder sb = new StringBuilder();
				for (char c: searchFor.toCharArray()) {
					if (!Character.isLetter(c) && !Character.isDigit(c))
						sb.append('\\');
					sb.append(c);
				}
				searchFor = sb.toString();
			}
			p = Pattern.compile(searchFor, (ignoreCase ? Pattern.CASE_INSENSITIVE : 0));
		} catch (PatternSyntaxException e) {
			return "Invalid regular expression.";
		}
		for (int i = previousFrameIndex;
				i < getCurrentTtyrec().getFrameCount() && i >= 0; i += searchForward ? 1 : -1) {
			if (i == previousFrameIndex) {
				continue;
			}
			if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
				goToSpecificFrame(i, true);
				return "Found at frame " + i + ".";
			}
		}
		if (wrapAround) {
			for (int i = searchForward ? 0 : getCurrentTtyrec().getFrameCount() - 1;
					i != previousFrameIndex;
					i += searchForward ? 1 : -1) {
				if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
					goToSpecificFrame(i, true);
					return "Found at frame " + i + " (wrapped).";
				}
			}
		}
		return "Match not found.";
	}

	/**
	 * A listener called when the window loses clipboard ownership.
	 * @param clipboard The clipboard whose ownership was lost.
	 * @param contents The contents of the lost clipboard.
	 */
	public void lostOwnership(Clipboard clipboard, Transferable contents) {
		// We don't care.
	}

	private void setSidebarPaneContents(AttributedString[] string) {
		sidebarPane.setStartToEnd(true);
		sidebarPane.setContents(Arrays.asList(string));
	}

	static int sidebarUpdates = 0;
	private void updateSidebar() {
		if (sidebarPane == null) return; /* we're in the constructor */
		// Java is rather bad at garbage-collecting the text used for the
		// sidebar labels, for some reason. So every 100000 sidebar updates,
		// we run GC by hand.
		sidebarUpdates++;
		if (sidebarUpdates >= 100000) {
			sidebarUpdates = 0;
			//System.gc();
		}
		// TODO: Fix magic numbers.
		// 0 = properties; 1 = annotations; 2 = playlist; 3 = raw data
		if (sidebarTypeComboBox.getSelectedIndex() == 0)
			setSidebarPropertyMessage();
		if (sidebarTypeComboBox.getSelectedIndex() == 1) {
			if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
				sidebarPane.setStartToEnd(true);
				setSidebarPaneContents(new AttributedString[]
						{new AttributedString("No file loaded.")});
			} else if (getCurrentTtyrec().getFileType() == Ttyrec.FileType.Ttyrec) {
				sidebarPane.setStartToEnd(true);
				setSidebarPaneContents(new AttributedString[]
						{new AttributedString("No annotations available.")});
			} else {
				sidebarPane.setStartToEnd(false);
				sidebarPane.setContents(getCurrentFrame().
						getRawDataIterator((double)timeSlider.getValue()
							/ timeScaling, 1));
			}
		}
		if (sidebarTypeComboBox.getSelectedIndex() == 3) {
			if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
				sidebarPane.setStartToEnd(true);
				setSidebarPaneContents(new AttributedString[]
						{new AttributedString("No file loaded.")});
			} else {
				sidebarPane.setStartToEnd(false);
				sidebarPane.setContents(getCurrentFrame().
						getRawDataIterator((double)timeSlider.getValue()
							/ timeScaling, 0));
			}
		}
	}

	/**
	 * Gets the currently visible ttyrec source; that's the selected source from
	 * the playlist.
	 * @return the currently selected ttyrec source.
	 */
	private TtyrecSource getCurrentSource() {
		return currentSource;
	}


	/**
	 * Returns the currently viewed ttyrec.
	 * Even if more than one ttyrec is open, only the one currently showing is
	 * returned.
	 * @return The current ttyrec, or null if there are no open ttyrecs.
	 */
	public Ttyrec getCurrentTtyrec() {
		if (getCurrentSource() == null) return null;
		return getCurrentSource().getTtyrec();
	}

	// This method exists to avoid causing problems with missing fields
	// in early JDK versions.
	private Object safelyGetRenderingHint(String hintName) {
		try {
			return RenderingHints.class.getField(hintName).get(null);
		} catch(NoSuchFieldException | SecurityException |
				IllegalArgumentException | IllegalAccessException e) {
			return RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
		}
	}

	/**
	 * The main entry point for the Jettyplay application.
	 * Parses and applies the effects of command-line arguments; if the
	 * arguments did not request an immediate exit, also creates a new main
	 * window for the Jettyplay application GUI and shows it.
	 * @param args The command-line arguments to parse.
	 */
	public static void main(String[] args) {
		// Look for help or version args, and reply and exit if one is given.
		boolean ddflag = false;
		for(String a : args) {
			if (ddflag) {ddflag = false; continue;}
			if(a.equals("-v") || a.equals("--version")) {
				System.err.println("This is jettyplay version "+
						AboutDialog.versionInfo+".");
				System.err.println(AboutDialog.copyrightInfo);
				System.exit(0);
			}
			if(a.equals("-h") || a.equals("--help")) {
				System.err.println("filenames   Load the given file/files");
				System.err.println("-z 80x24    Force terminal size to 80x24 (likewise for other sizes)");
				System.err.println("-f 1200     Jump to frame 1200 upon loading (likewise for other frames)");
				System.err.println("-s 4        Set speed to 4x realtime (likewise for other speeds)");
				System.err.println("-l          Automatically fast-forward through periods of inactivity");
				System.err.println("--          Treat next arg as a filename even if it starts with -");
				System.err.println("-h          Show this help, then exit");
				System.err.println("-v          Show version and copyright information, then exit");
				System.exit(0);
			}
			if(a.equals("--")) ddflag = true;
		}
		// Set up the GUI.
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (ClassNotFoundException | InstantiationException |
				IllegalAccessException | UnsupportedLookAndFeelException ex) {
			// if we can't set a system look and feel, just use the default...
		}
		MainFrame me = new MainFrame();
		me.setDefaultCloseOperation(EXIT_ON_CLOSE);
		me.setSize(800, 600);
		me.setTitle("Jettyplay");
		me.setVisible(true);
		// Apply the effects of options
		ddflag = false;
		boolean speedflag = false;
		boolean sizeflag = false;
		boolean frameflag = false;
		String pendingSize = null;
		String pendingFrame = null;
		for (String a : args) {
			if (speedflag) {
				try {
					me.speedSpinner.setValue(Double.valueOf(a));
				} catch (NumberFormatException ex) {
					// ignore invalid input
				}
				speedflag = false;
				continue;
			}
			// if size or frame is being set this arg, turn on ddflag so the
			// arg isn't interpreted as anything else, and fall past the
			// filename check to the size/frame check
			if (sizeflag) {pendingSize = a; ddflag = true;}
			if (frameflag) {pendingFrame = a; ddflag = true;}
			if (a.equals("-l") && !ddflag) {
				me.autoskipButton.setSelected(true);
				me.autoskipMenuItem.setSelected(true);
				me.updateSidebar();
				continue;
			}
			if(a.equals("-s") && !ddflag) {speedflag = true; continue;}
			if(a.equals("-f") && !ddflag) {frameflag = true; continue;}
			if(a.equals("-z") && !ddflag) {sizeflag = true; continue;}
			if(a.equals("--") && !ddflag) {ddflag = true; continue;}            
			ddflag = false;
			if (!sizeflag && !frameflag) {
				// Looks like it's a filename...
				File f = new File(a);
				me.openSourceFromInputStreamable(new InputStreamableFileWrapper(f));
			}
			// Check to see whether to apply forced size, or to go to a frame.
			sizeflag = false;
			frameflag = false;
			if (me.getCurrentSource() != null && pendingSize != null) {
				me.setForcedSizeFromString(pendingSize);
				pendingSize = null;
			}
			if (me.getCurrentSource() != null && pendingFrame != null) {
				try {
					me.getCurrentSource().setWantedFrame(
							Integer.valueOf(pendingFrame) - 1);
					pendingFrame = null;
				} catch (NumberFormatException nfe) {
					// do nothing
				}
			}
		}
	}
}
