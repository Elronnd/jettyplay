/*
 * MainFrame.java
 */

package jettyplay;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.Font;
import java.awt.RenderingHints;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.net.URISyntaxException;
import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.HierarchyEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.text.AttributedString;
import java.util.Arrays;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.stream.MemoryCacheImageOutputStream;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileFilter;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSlider;
import javax.swing.JSpinner;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

/**
 * The application's main frame.
 */
@SuppressWarnings("serial")
public class MainFrame extends JFrame
implements ClipboardOwner, TemporalProgress {

	/**
	 * Creates a new main window for the Jettyplay application.
	 */
	public MainFrame() {
		initComponents();
		// some components the autogenerated code doesn't know about
		sidebarPane = new SidebarPanel(new AttributedString[] {
				new AttributedString("This is a free GPL program, but comes with "+
						"no warranty. See Help | Licence Information for details.")
				});
		sidebarToolbar.add(sidebarPane);

		// set no file to be open
		currentSource = null;
	}

	/**
	 * Shows the About... dialog box.
	 */
	public void showAboutBox() {
		if (aboutBox == null) {
			JFrame mainFrame = this;
			aboutBox = new AboutDialog(mainFrame);
			aboutBox.setLocationRelativeTo(mainFrame);
		}
		aboutBox.setVisible(true);
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 */
	@SuppressWarnings("unchecked")
		private void initComponents() {
			/* This was originally generated by NetBean's Form Editor, but it
			 * lost track of the form upon an upgrade to a new version. So now
			 * it's being edited by hand.
			 */
			uiBuilder = new UIBuilder(false);

			mainPanel = uiBuilder.addJPanel(getContentPane(), null);
			JPanel mainToolbarPanel = uiBuilder.addJPanel(mainPanel, BorderLayout.CENTER);

			mainToolbar = uiBuilder.addJToolBar(mainToolbarPanel, BorderLayout.NORTH);

			uiBuilder.addJSeparator(mainToolbar);

			/* We do this one by hand, because it's a little complex and because
			   there's no code reuse benefit from uiBuilder. */

			autoskipButton = uiBuilder.addJToggleButton(mainToolbar,
					"Automatically skip past long periods of inactivity",
					"autoskip.png", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autoskipButtonStateChanged(evt);
					}
					});

			sidebarToolbarPanel = uiBuilder.addJPanel(mainToolbarPanel,
					BorderLayout.CENTER);

			sidebarToolbar = uiBuilder.addJToolBar(sidebarToolbarPanel,
					BorderLayout.SOUTH);
			sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar, BoxLayout.X_AXIS));

			/* Another by-hand addition. */
			sidebarTypeComboBox = new JComboBox<>();
			sidebarTypeComboBox.setModel(new DefaultComboBoxModel<>(
						new String[] { "Properties", "Annotations", "Playlist", "Raw Data" }));
			sidebarTypeComboBox.setFocusable(false);
			sidebarTypeComboBox.setMaximumSize(sidebarTypeComboBox.getPreferredSize());
			sidebarTypeComboBox.setName("sidebarTypeComboBox"); // NOI18N
			sidebarTypeComboBox.addItemListener(new ItemListener() {
					public void itemStateChanged(ItemEvent evt) {
					sidebarTypeComboBoxItemStateChanged(evt);
					}
					});
			sidebarTypeComboBox.addHierarchyBoundsListener(new HierarchyBoundsListener() {
					public void ancestorMoved(HierarchyEvent evt) {
					}
					public void ancestorResized(HierarchyEvent evt) {
					sidebarTypeComboBoxAncestorResized(evt);
					}
					});
			sidebarToolbar.add(sidebarTypeComboBox);

			menuBar = new JMenuBar();

			fileMenu = uiBuilder.addJMenu(menuBar, 'f', "File");
			uiBuilder.addJMenuItem(fileMenu, 'o', "Open...", "control O", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					openMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(fileMenu);
			uiBuilder.addJMenuItem(fileMenu, 'v', "Save as Video...", null,
					true, new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					saveAsVideoMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(fileMenu);
			uiBuilder.addJMenuItem(fileMenu, 'x', "Exit", "control X", false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					exitMenuItemActionPerformed(evt);
					}
					});

			JMenu editMenu = uiBuilder.addJMenu(menuBar, 'e', "Edit");
			uiBuilder.addJMenuItem(editMenu, 'f', "Find...", "control F", true,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					findMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJSeparator(editMenu);
			screenshotMenu = uiBuilder.addJMenu(editMenu, 'c',
					"Copy Screenshot");
			uiBuilder.addJMenuItem(screenshotMenu, 'p', "As Plain Text",
					null, true, new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					plainTextScreenshotMenuItemActionPerformed(evt);
					}
					});
			viewMenu = uiBuilder.addJMenu(menuBar, 'v', "View");
			fullScreenMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'f',
					"Full Screen", "F11", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					fullScreenMenuItemStateChanged(evt);
					}
					});
			fullScreenMenuItem.setEnabled(
					GraphicsEnvironment.getLocalGraphicsEnvironment()
					.getDefaultScreenDevice().isFullScreenSupported());
			sidebarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'i',
					"Information Bar", null, false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					sidebarMenuItemStateChanged(evt);
					}
					});
			sidebarMenuItem.setSelected(true);
			toolBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 't',
					"Toolbar", null, false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					toolBarMenuItemStateChanged(evt);
					}
					});
			toolBarMenuItem.setSelected(true);
			menuBarMenuItem = uiBuilder.addJCheckBoxMenuItem(viewMenu, 'm',
					"Menu Bar", "control M", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					menuBarMenuItemStateChanged(evt);
					}
					});
			uiBuilder.addJSeparator(viewMenu);
			ButtonGroup terminalSizeGroup = new ButtonGroup();
			JMenu terminalSizeMenu = uiBuilder.addJMenu(viewMenu, 'z', "Terminal Size");
			autodetectTerminalSizeMenuItem = uiBuilder.addJRadioButtonMenuItem(
					terminalSizeMenu, 'a', "Autodetect", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autodetectTerminalSizeMenuItemActionPerformed(evt);
					}
					});
			terminalSizeGroup.add(autodetectTerminalSizeMenuItem);
			autodetectTerminalSizeMenuItem.setSelected(true);
			fixedTerminalSizeMenuItem = uiBuilder.addJRadioButtonMenuItem(
					terminalSizeMenu, 'f', "Fixed Size...", null, true,
					new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {}
					});
			fixedTerminalSizeMenuItem.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					fixedTerminalSizeMenuItemActionPerformed(evt);
					}
					});
			encodingMenu = uiBuilder.addJMenu(viewMenu, 'e', "Encoding");
			ButtonGroup encodingButtonGroup = new ButtonGroup();
			autodetectEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'a', "Autodetect", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autodetectEncodingMenuItemStateChanged(evt);
					}
					});
			encodingButtonGroup.add(autodetectEncodingMenuItem);
			autodetectEncodingMenuItem.setSelected(true);
			unicodeEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'u', "Unicode (UTF-8)", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					unicodeEncodingMenuItemStateChanged(evt);
					}
					});
			encodingButtonGroup.add(unicodeEncodingMenuItem);
			ibmEncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'i', "IBM (IBM850)", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					ibmEncodingMenuItemStateChanged(evt);
					}
					});
			encodingButtonGroup.add(autodetectEncodingMenuItem);
			latin1EncodingMenuItem = uiBuilder.addJRadioButtonMenuItem(
					encodingMenu, 'l', "Latin-1 (ISO-8859-1)", null, true, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					latin1EncodingMenuItemStateChanged(evt);
					}
					});
			JMenu goMenu = uiBuilder.addJMenu(menuBar, 'g', "Go");
			uiBuilder.addJSeparator(goMenu);
			autoskipMenuItem =uiBuilder.addJCheckBoxMenuItem(goMenu,
					'k', "Skip Inactivity", "L", false, new ChangeListener() {
					public void stateChanged(ChangeEvent evt) {
					autoskipMenuItemStateChanged(evt);
					}
					});
			JMenu helpMenu = uiBuilder.addJMenu(menuBar, 'h', "Help");
			uiBuilder.addJMenuItem(helpMenu, 'a', "About...", null, false,
					new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					aboutMenuItemActionPerformed(evt);
					}
					});
			uiBuilder.addJMenuItem(helpMenu, 'l', "License information...", null,
					false, new ActionListener() {
					public void actionPerformed(ActionEvent evt) {
					licenceMenuItemActionPerformed(evt);
					}
					});

			setJMenuBar(menuBar);
			uiBuilder.massSetEnabled(false);
		}

	/**
	 * A function that runs when the Open menu item is selected, that opens
	 * a ttyrec file.
	 * @param evt Information on which event was performed
	 */
	private void openMenuItemActionPerformed(ActionEvent evt) {
		InputStreamable iStream = null;

		BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));

		boolean gotstring = false;
		String s = "";
		while (!gotstring) {
			try {
				s = stdin.readLine();
				gotstring = true;
			} catch (IOException e) {
			}
		}


		File f = new File(s);
		iStream = new InputStreamableFileWrapper(f);

		if (iStream == null) return;

		openSourceFromInputStreamable(iStream);
	}

	private void licenceMenuItemActionPerformed(ActionEvent evt) {
		new LicenceDialog(this).setVisible(true);
	}

	private void autoskipButtonStateChanged(ChangeEvent evt) {
		autoskipMenuItem.setSelected(autoskipButton.isSelected());
		updateSidebar();
	}

	private void autoskipMenuItemStateChanged(ChangeEvent evt) {
		autoskipButton.setSelected(autoskipMenuItem.isSelected());
		updateSidebar();
	}

	private void unicodeEncodingMenuItemStateChanged(ChangeEvent evt) {
		if (unicodeEncodingMenuItem.isSelected())
			setTtyrecFormat(Ttyrec.Encoding.UTF8);
	}

	private void ibmEncodingMenuItemStateChanged(ChangeEvent evt) {
		if (ibmEncodingMenuItem.isSelected())
			setTtyrecFormat(Ttyrec.Encoding.IBM);
	}

	private void latin1EncodingMenuItemStateChanged(ChangeEvent evt) {
		if (latin1EncodingMenuItem.isSelected())
			setTtyrecFormat(Ttyrec.Encoding.Latin1);
	}

	private void fullScreenMenuItemStateChanged(ChangeEvent evt) {
		GraphicsEnvironment.getLocalGraphicsEnvironment().
			getDefaultScreenDevice().setFullScreenWindow(
					fullScreenMenuItem.isSelected() ?
					this : null);
	}

	private void sidebarMenuItemStateChanged(ChangeEvent evt) {
		sidebarToolbar.setVisible(sidebarMenuItem.isSelected());
	}

	private void toolBarMenuItemStateChanged(ChangeEvent evt) {
		mainToolbar.setVisible(toolBarMenuItem.isSelected());
	}

	private void menuBarMenuItemStateChanged(ChangeEvent evt) {
		if (menuBarMenuItem.isSelected()) {
			if (!menuBarShowing) {
				//menuBar.setPreferredSize(new Dimension(32767,savedMenuBarHeight));
				menuBar.setPreferredSize(null);
				menuBar.setVisible(false);
				menuBar.setVisible(true);
				menuBarShowing = true;
			}
		} else {
			if (menuBarShowing) {
				menuBar.setPreferredSize(new Dimension(32767,1));
				menuBar.setVisible(false);
				menuBar.setVisible(true);
				menuBarShowing = false;
			}
		}
	}

	private void findMenuItemActionPerformed(ActionEvent evt) {
		if (findBox == null)
			findBox = new FindDialog(this,this);
		findBox.setVisible(true);
		findBox.fixDefaultFocus();
		findBox.requestFocusInWindow();
	}

	private void plainTextScreenshotMenuItemActionPerformed(ActionEvent evt) {
		VDUBuffer vdub = null;
		if (getCurrentTtyrec() != null) vdub = getCurrentFrame().getTerminalState();
		if (vdub == null) vdub = new vt320();
		StringBuilder sb = new StringBuilder();
		for (char[] s: vdub.charArray) {
			sb.append(s);
			sb.append('\n');
		}
		setClipboardContents(new StringSelection(sb.toString()));
	}

	private void sidebarTypeComboBoxAncestorResized(HierarchyEvent evt) {
		int oldOrientation = sidebarToolbar.getOrientation();
		sidebarToolbar.setLayout(new BoxLayout(sidebarToolbar,
					oldOrientation == SwingConstants.HORIZONTAL ?
					BoxLayout.X_AXIS : BoxLayout.Y_AXIS));
		// fix layout
		sidebarToolbar.invalidate();
		sidebarToolbar.validate();
		// fix sizing (by forcing a size recalculation)
		sidebarToolbar.setOrientation(SwingConstants.HORIZONTAL);
		sidebarToolbar.setOrientation(SwingConstants.VERTICAL);
		sidebarToolbar.setOrientation(oldOrientation);
		sidebarPane.setVertical(oldOrientation == SwingConstants.VERTICAL);
	}

	private void sidebarTypeComboBoxItemStateChanged(ItemEvent evt) {
		updateSidebar();
	}

	private void aboutMenuItemActionPerformed(ActionEvent evt) {
		new AboutDialog(this).setVisible(true);
	}

	private void exitMenuItemActionPerformed(ActionEvent evt) {
		System.exit(0);
	}

	private void autodetectEncodingMenuItemStateChanged(ChangeEvent evt) {
		if (autodetectEncodingMenuItem.isSelected() && getCurrentTtyrec() != null)
			getCurrentTtyrec().resetEncoding();
	}

	private void saveAsVideoMenuItemActionPerformed(ActionEvent evt) {
		/* We don't check to see if analyze process is maxed out, because in
		 * the case of streaming ttyrecs, there's no way to tell.
		 */
		if (currentSource.getTtyrec() != null &&
				currentSource.getTtyrec().getFrameCount() > 0 &&
				currentSource.backportDecodeProgress()
				>= currentSource.getTtyrec().getFrameCount())
			new SaveAsVideoDialog(currentSource.getTtyrec(), "/tmp/jettyplay_tmp.avi");
		else
			JOptionPane.showMessageDialog(fileMenu,
					"Please wait for the ttyrec to finish loading first.",
					"Cannot Save as Video", JOptionPane.ERROR_MESSAGE);
	}

	private void autodetectTerminalSizeMenuItemActionPerformed(ChangeEvent evt) {
		if (autodetectTerminalSizeMenuItem.isSelected() && getCurrentTtyrec() != null) {
			getCurrentTtyrec().setForcedSize(-1,-1);
			autodetectTerminalSizeMenuItem.setSelected(true);
			fixedTerminalSizeMenuItem.setSelected(false);
			getCurrentSource().repeatCurrentDecodeWorker();
		}
	}

	private void fixedTerminalSizeMenuItemActionPerformed(ActionEvent evt) {
		if (fixedTerminalSizeMenuItem.isSelected()) {
			String s = JOptionPane.showInputDialog(viewMenu,
					"Fix terminal window at what size (WxH)?", "80x24");
			if (s == null) return;
			setForcedSizeFromString(s);
		}
	}

	private void setForcedSizeFromString(String s) {
		Matcher m = Pattern.compile("\\s*(\\d+)\\s*x\\s*(\\d+)\\s*").
			matcher(s);
		if (!m.matches()) return;
		getCurrentTtyrec().setForcedSize(
				Integer.valueOf(m.group(1)), Integer.valueOf(m.group(2)));
		autodetectTerminalSizeMenuItem.setSelected(false);
		fixedTerminalSizeMenuItem.setSelected(true);
		getCurrentSource().repeatCurrentDecodeWorker();
	}

	private void setClipboardContents(Transferable t) {
		try {
			this.getToolkit().
				getSystemClipboard().setContents(t, this);
		} catch (java.security.AccessControlException ex) {
			try {
				// Try using a JNLP service to access the clipboard.

				// ClipboardService cs = (ClipboardService) ServiceManager.lookup("javax.jnlp.ClipboardService");
				Object cs = getClass().getClassLoader().loadClass("javax.jnlp.ServiceManager").
					getMethod("lookup", String.class).invoke(null, "javax.jnlp.ClipboardService");
				// cs.setContents(t);
				getClass().getClassLoader().loadClass("javax.jnlp.ClipboardService").
					getMethod("setContents", Transferable.class).invoke(cs, t);
			} catch (ClassNotFoundException | NoSuchMethodException |
					SecurityException | IllegalAccessException |
					IllegalArgumentException | InvocationTargetException ex1) {
				return;
			}
		}
	}

	private void setTtyrecFormat(Ttyrec.Encoding format) {
		if (getCurrentTtyrec() == null) return;
		if (getCurrentTtyrec().getEncoding() == format) return;
		getCurrentTtyrec().setEncoding(format);
		getCurrentSource().repeatCurrentDecodeWorker();
	}

	private String timeToString(double time) {
		int t = (int)time;
		if (t<0) t = 0;
		String s = (t/60) + ":";
		if (t > 3600) {
			s = (t/3600) + ":";
			if ((t/60)%60 < 10) s += "0";
			s += (t/60)%60 + ":";
		}
		if (t%60 < 10) s += "0";
		s += t%60;
		return s;
	}

	private boolean oldEnabled = false;
	private void massSetEnabled(boolean enabled) {
		if (enabled == oldEnabled) return;
		oldEnabled = enabled;
		if (!enabled) {
			unicodeEncodingMenuItem.setEnabled(enabled);
			ibmEncodingMenuItem.setEnabled(enabled);
			latin1EncodingMenuItem.setEnabled(enabled);
		}
		uiBuilder.massSetEnabled(enabled);
	}

	private void unloadFile() {
		playing = false;
		massSetEnabled(false);
		if (getCurrentSource() != null) getCurrentSource().completeCancel();
		currentSource = null;
		VDUBuffer.resetCaches();
		updateSidebar();
	}

	private void openSourceFromInputStreamable(InputStreamable iStream) {
		unloadFile();
		currentSource = new InputStreamTtyrecSource(iStream);
		getCurrentSource().completeUnpause();
		getCurrentSource().addDecodeListener(new ProgressListener() {
				public void progressMade() {
				}
				});
		getCurrentSource().addAnalysisListener(new ProgressListener() {
				public void progressMade() {
				analysisProgressMade();
				}
				});
		getCurrentSource().addReadListener(new ProgressListener() {
				public void progressMade() {
				}
				});
		getCurrentSource().start();
		massSetEnabled(true);
		previousFrameIndex = 0;
	}

	// Variable declarations
	private JRadioButtonMenuItem allowBoldMenuItem;
	private JRadioButtonMenuItem autodetectEncodingMenuItem;
	private JRadioButtonMenuItem autodetectTerminalSizeMenuItem;
	private JToggleButton autoskipButton;
	private JCheckBoxMenuItem autoskipMenuItem;
	private JRadioButtonMenuItem disallowBoldMenuItem;
	private JMenu encodingMenu;
	private JMenu fileMenu;
	private JRadioButtonMenuItem fixedTerminalSizeMenuItem;
	private JCheckBoxMenuItem fullScreenMenuItem;
	private JRadioButtonMenuItem ibmEncodingMenuItem;
	private JRadioButtonMenuItem latin1EncodingMenuItem;
	private JPanel mainPanel;
	private JToolBar mainToolbar;
	private JMenuBar menuBar;
	private JCheckBoxMenuItem menuBarMenuItem;
	private JMenu screenshotMenu;
	private JCheckBoxMenuItem sidebarMenuItem;
	private JToolBar sidebarToolbar;
	private JPanel sidebarToolbarPanel;
	private JComboBox<String> sidebarTypeComboBox;
	private JCheckBoxMenuItem toolBarMenuItem;
	private JRadioButtonMenuItem unicodeEncodingMenuItem;
	private JMenu viewMenu;
	private UIBuilder uiBuilder;
	private SidebarPanel sidebarPane;
	private boolean menuBarShowing = true;

	private TtyrecSource currentSource;

	// TODO: Reduce this in the case of excessively time-long ttyrecs,
	// to avoid an integer overflow
	private int timeScaling = 1000;
	private boolean playing = false;
	private int previousFrameIndex = -1;
	private long timeStartedAt;
	private int sliderValueStartedAt;
	private boolean canUpdateTimeStartedAt = true;
	private boolean canUpdateSelectedFrame = true;

	private JDialog aboutBox;
	private FindDialog findBox;

	private File lastDirectory = null;

	public double getMaximumTime() {
		if (getCurrentTtyrec() == null) return 0.0;
		return getCurrentTtyrec().getLength();
	}
	public double getCurrentTime() {
		if (getCurrentTtyrec() == null) return 0.0;
		if (getCurrentSource().backportDecodeProgress() ==
				getCurrentTtyrec().getFrameCount())
			return getCurrentTtyrec().getLength();
		if (getCurrentSource().backportDecodeProgress() == 0) return 0.0;
		return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().backportDecodeProgress()-1).getRelativeTimestamp();
	}
	public double getFuzzyTime() {
		if (getCurrentTtyrec() == null) return 0.0;
		if (getCurrentSource().decodeProgress() == getCurrentTtyrec().getFrameCount())
			return getCurrentTtyrec().getLength();
		if (getCurrentSource().decodeProgress() == 0) return 0.0;
		return getCurrentTtyrec().getFrameAtIndex(getCurrentSource().decodeProgress()-1).getRelativeTimestamp();
	}

	/**
	 * A listener that should be called whenever progress has been made in
	 * analysing a currently open ttyrec.
	 */
	public void analysisProgressMade() {
		updateSidebar();
		// Synch the selected encoding from the ttyrec...
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Autodetect)
			autodetectEncodingMenuItem.setSelected(true);
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.IBM)
			ibmEncodingMenuItem.setSelected(true);
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.Latin1)
			latin1EncodingMenuItem.setSelected(true);
		if (getCurrentTtyrec().getEncoding() == Ttyrec.Encoding.UTF8)
			unicodeEncodingMenuItem.setSelected(true);
		// /before/ setting which item is enabled, or we'll end up copying
		// the old value over the new one rather than vice versa.
		ibmEncodingMenuItem.setEnabled
			(getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.IBM));
		unicodeEncodingMenuItem.setEnabled
			(getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.UTF8));
		latin1EncodingMenuItem.setEnabled
			(getCurrentTtyrec().isEncodingPossible(Ttyrec.Encoding.Latin1));
		// if we just decoded the wanted frame, jump to it
		if (getCurrentTtyrec().getWantedFrame() > -1 &&
				getCurrentTtyrec().getFrameCount() >
				getCurrentTtyrec().getWantedFrame()) {
			getCurrentTtyrec().setWantedFrame(-1);
		}
	}

	private TtyrecFrame getCurrentFrame() {
		try {
			return getCurrentTtyrec().getFrameAtIndex(previousFrameIndex);
		} catch(IndexOutOfBoundsException ex) {
			return null;
		}
	}

	private void setSidebarPropertyMessage() {
		if (getCurrentTtyrec() != null) {
			AttributedString[] as = new AttributedString[7];
			as[0] = new AttributedString(playing ? "Playing" : "Paused");
			as[0].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD);
			as[1] = new AttributedString("Frame: " + (previousFrameIndex+1) +
					" / " + getCurrentTtyrec().getFrameCount());
			as[1].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
			as[2] = new AttributedString("Time: ");
			as[2].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,4);
			as[3] = new AttributedString("Speed: ");
			as[3].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
			try {
				as[4] = new AttributedString("Size: " +
						getCurrentFrame().getTerminalState().getColumns() +
						" x " + getCurrentFrame().getTerminalState().getRows());
			} catch (Exception e) {
				as[4] = new AttributedString("Size: ? x ?");
			}
			as[4].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,5);
			as[5] = new AttributedString("Memory used: " +
					((Runtime.getRuntime().totalMemory()) - Runtime.getRuntime().freeMemory()) +
					" / " + Runtime.getRuntime().maxMemory());
			as[5].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,11);
			try {
				as[6] = new AttributedString("URI: " + getCurrentSource().getURI().toString());
			} catch (URISyntaxException ex) {
				as[6] = new AttributedString("URI: unknown");
			}
			as[6].addAttribute(TextAttribute.WEIGHT,TextAttribute.WEIGHT_BOLD,0,3);
			setSidebarPaneContents(as);
		} else {
			setSidebarPaneContents(new AttributedString[]
					{new AttributedString("No file loaded.")});
		}
	}

	/**
	 * Searches for a given string in the currently open ttyrec; if it's found,
	 * then seeks the current ttyrec to the frame where it was found.
	 * @param searchFor The string to search for.
	 * @param searchForward Whether to search forwards (true) or backwards (false).
	 * @param regex Whether the string to search for is actually a regex.
	 * @param ignoreCase Whether to do a case-insensitive (true) or case-sensitive (false) search.
	 * @param wrapAround Whether to restart the search at one end of the ttyrec if it's finished at the other end.
	 * @return A string that can be displayed to the user, summarising the results of the search.
	 */
	public String searchInTtyrec(String searchFor, boolean searchForward,
			boolean regex, boolean ignoreCase, boolean wrapAround) {
		Pattern p;
		try {
			// Regex.LITERAL would be nice, but it's too new. So we quote the
			// regex by hand, according to Perl 5 quoting rules; all letters
			// and all digits are left as-is, other characters are preceded by
			// a backslash.
			if (!regex) {
				StringBuilder sb = new StringBuilder();
				for (char c: searchFor.toCharArray()) {
					if (!Character.isLetter(c) && !Character.isDigit(c))
						sb.append('\\');
					sb.append(c);
				}
				searchFor = sb.toString();
			}
			p = Pattern.compile(searchFor, (ignoreCase ? Pattern.CASE_INSENSITIVE : 0));
		} catch (PatternSyntaxException e) {
			return "Invalid regular expression.";
		}
		for (int i = previousFrameIndex;
				i < getCurrentTtyrec().getFrameCount() && i >= 0; i += searchForward ? 1 : -1) {
			if (i == previousFrameIndex) {
				continue;
			}
			if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
				return "Found at frame " + i + ".";
			}
		}
		if (wrapAround) {
			for (int i = searchForward ? 0 : getCurrentTtyrec().getFrameCount() - 1;
					i != previousFrameIndex;
					i += searchForward ? 1 : -1) {
				if (getCurrentTtyrec().getFrameAtIndex(i).containsPattern(p)) {
					return "Found at frame " + i + " (wrapped).";
				}
			}
		}
		return "Match not found.";
	}

	/**
	 * A listener called when the window loses clipboard ownership.
	 * @param clipboard The clipboard whose ownership was lost.
	 * @param contents The contents of the lost clipboard.
	 */
	public void lostOwnership(Clipboard clipboard, Transferable contents) {
		// We don't care.
	}

	private void setSidebarPaneContents(AttributedString[] string) {
		sidebarPane.setStartToEnd(true);
		sidebarPane.setContents(Arrays.asList(string));
	}

	static int sidebarUpdates = 0;
	private void updateSidebar() {
		if (sidebarPane == null) return; /* we're in the constructor */
		// Java is rather bad at garbage-collecting the text used for the
		// sidebar labels, for some reason. So every 100000 sidebar updates,
		// we run GC by hand.
		sidebarUpdates++;
		if (sidebarUpdates >= 100000) {
			sidebarUpdates = 0;
			//System.gc();
		}
		// TODO: Fix magic numbers.
		// 0 = properties; 1 = annotations; 2 = playlist; 3 = raw data
		if (sidebarTypeComboBox.getSelectedIndex() == 0)
			setSidebarPropertyMessage();
		if (sidebarTypeComboBox.getSelectedIndex() == 1) {
			if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
				sidebarPane.setStartToEnd(true);
				setSidebarPaneContents(new AttributedString[]
						{new AttributedString("No file loaded.")});
			} else if (getCurrentTtyrec().getFileType() == Ttyrec.FileType.Ttyrec) {
				sidebarPane.setStartToEnd(true);
				setSidebarPaneContents(new AttributedString[]
						{new AttributedString("No annotations available.")});
			} else {
				sidebarPane.setStartToEnd(false);
			}
		}
		if (sidebarTypeComboBox.getSelectedIndex() == 3) {
			if (getCurrentTtyrec() == null || getCurrentFrame() == null) {
				sidebarPane.setStartToEnd(true);
				setSidebarPaneContents(new AttributedString[]
						{new AttributedString("No file loaded.")});
			} else {
				sidebarPane.setStartToEnd(false);
			}
		}
	}

	/**
	 * Gets the currently visible ttyrec source; that's the selected source from
	 * the playlist.
	 * @return the currently selected ttyrec source.
	 */
	private TtyrecSource getCurrentSource() {
		return currentSource;
	}


	/**
	 * Returns the currently viewed ttyrec.
	 * Even if more than one ttyrec is open, only the one currently showing is
	 * returned.
	 * @return The current ttyrec, or null if there are no open ttyrecs.
	 */
	public Ttyrec getCurrentTtyrec() {
		if (getCurrentSource() == null) return null;
		return getCurrentSource().getTtyrec();
	}

	// This method exists to avoid causing problems with missing fields
	// in early JDK versions.
	private Object safelyGetRenderingHint(String hintName) {
		try {
			return RenderingHints.class.getField(hintName).get(null);
		} catch(NoSuchFieldException | SecurityException |
				IllegalArgumentException | IllegalAccessException e) {
			return RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
		}
	}

	/**
	 * The main entry point for the Jettyplay application.
	 * Parses and applies the effects of command-line arguments; if the
	 * arguments did not request an immediate exit, also creates a new main
	 * window for the Jettyplay application GUI and shows it.
	 * @param args The command-line arguments to parse.
	 */
	public static void main(String[] args) {
		// Look for help or version args, and reply and exit if one is given.
		boolean ddflag = false;
		for(String a : args) {
			if (ddflag) {ddflag = false; continue;}
			if(a.equals("-v") || a.equals("--version")) {
				System.err.println("This is jettyplay version "+
						AboutDialog.versionInfo+".");
				System.err.println(AboutDialog.copyrightInfo);
				System.exit(0);
			}
			if(a.equals("-h") || a.equals("--help")) {
				System.err.println("filenames   Load the given file/files");
				System.err.println("-z 80x24    Force terminal size to 80x24 (likewise for other sizes)");
				System.err.println("-f 1200     Jump to frame 1200 upon loading (likewise for other frames)");
				System.err.println("-l          Automatically fast-forward through periods of inactivity");
				System.err.println("--          Treat next arg as a filename even if it starts with -");
				System.err.println("-h          Show this help, then exit");
				System.err.println("-v          Show version and copyright information, then exit");
				System.exit(0);
			}
			if(a.equals("--")) ddflag = true;
		}
		// Set up the GUI.
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (ClassNotFoundException | InstantiationException |
				IllegalAccessException | UnsupportedLookAndFeelException ex) {
			// if we can't set a system look and feel, just use the default...
		}
		MainFrame me = new MainFrame();
		me.setDefaultCloseOperation(EXIT_ON_CLOSE);
		me.setSize(800, 600);
		me.setTitle("Jettyplay");
		me.setVisible(true);
		// Apply the effects of options
		ddflag = false;
		boolean sizeflag = false;
		boolean frameflag = false;
		String pendingSize = null;
		String pendingFrame = null;
		for (String a : args) {
			// if size or frame is being set this arg, turn on ddflag so the
			// arg isn't interpreted as anything else, and fall past the
			// filename check to the size/frame check
			if (sizeflag) {pendingSize = a; ddflag = true;}
			if (frameflag) {pendingFrame = a; ddflag = true;}
			if (a.equals("-l") && !ddflag) {
				me.autoskipButton.setSelected(true);
				me.autoskipMenuItem.setSelected(true);
				me.updateSidebar();
				continue;
			}
			if(a.equals("-f") && !ddflag) {frameflag = true; continue;}
			if(a.equals("-z") && !ddflag) {sizeflag = true; continue;}
			if(a.equals("--") && !ddflag) {ddflag = true; continue;}            
			ddflag = false;
			if (!sizeflag && !frameflag) {
				// Looks like it's a filename...
				File f = new File(a);
				me.openSourceFromInputStreamable(new InputStreamableFileWrapper(f));
			}
			// Check to see whether to apply forced size, or to go to a frame.
			sizeflag = false;
			frameflag = false;
			if (me.getCurrentSource() != null && pendingSize != null) {
				me.setForcedSizeFromString(pendingSize);
				pendingSize = null;
			}
			if (me.getCurrentSource() != null && pendingFrame != null) {
				try {
					me.getCurrentSource().setWantedFrame(
							Integer.valueOf(pendingFrame) - 1);
					pendingFrame = null;
				} catch (NumberFormatException nfe) {
					// do nothing
				}
			}
		}
	}
}
